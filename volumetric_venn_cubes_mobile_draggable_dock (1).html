<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Volumetric Venn Cubes ‚Äî DJ Deck Mode</title>
  <style>
    :root{
      --ink:#e7faff; --ui:#4fc3f7; --ui2:#00ff88; --warn:#ffaa00; --ghost:#9fb6c1;
      --panel:rgba(0,0,0,.86); --panel-2:rgba(255,255,255,.04); --edge:rgba(79,195,247,.35);
      --bad:#ff4b72; --good:#21ff86;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100%}
    body{ margin:0; background:#000; color:var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,"Courier New",monospace; overflow:hidden; }
    canvas{display:block; width:100vw; height:100vh; touch-action:none}

    .badge{position:fixed; left:12px; background:var(--panel); border:1px solid var(--edge); padding:8px 10px; border-radius:10px; font-size:11px; z-index:7; box-shadow:0 6px 24px rgba(0,0,0,.4)}
    #infoBadge{top:12px}
    #viewBadge{bottom:12px; color:var(--warn); border-color:rgba(255,170,0,.55)}
    #blendBadge{bottom:56px; color:var(--ui2); border-color:rgba(0,255,136,.55)}
    #fallbackBadge{bottom:100px; display:none; border-color:rgba(255,75,114,.55); color:#ffd5de}

    #dock{ position:fixed; right:14px; bottom:18px; width:min(92vw,380px); max-width:420px; background:var(--panel); border:1px solid var(--edge); border-radius:14px; z-index:9; box-shadow:0 10px 40px rgba(0,0,0,.55); backdrop-filter: blur(4px); }
    .dock-header{ display:flex; align-items:center; gap:10px; padding:10px 12px; border-bottom:1px solid var(--edge); cursor:grab; touch-action:none; user-select:none; }
    .grip{width:28px; height:6px; border-radius:6px; background:linear-gradient(90deg, var(--edge) 20%, transparent 20% 40%, var(--edge) 40% 60%, transparent 60% 80%, var(--edge) 80%); opacity:.9}
    .dock-title{font-size:12px; letter-spacing:.08em; text-transform:uppercase; color:var(--ui)}
    .dock-actions{margin-left:auto; display:flex; gap:8px}
    .chip{font-size:11px; padding:6px 8px; border-radius:10px; border:1px solid var(--edge); background:var(--panel-2); color:var(--ink); cursor:pointer}

    .dock-body{padding:10px 12px; max-height:min(62vh, 480px); overflow:auto}
    .section{border:1px solid var(--edge); background:var(--panel-2); border-radius:10px; margin-bottom:10px}
    .section summary{ list-style:none; display:flex; align-items:center; gap:8px; padding:8px 10px; font-size:12px; color:var(--ui); cursor:pointer; user-select:none }
    .section summary::-webkit-details-marker{display:none}
    .section .content{padding:8px 10px; display:grid; gap:10px}

    .row{display:flex; gap:8px; flex-wrap:wrap}
    button.btn{flex:1; min-width:72px; font-weight:700; font-size:11px; padding:9px 10px; color:var(--ink); background:rgba(79,195,247,.16); border:1px solid var(--edge); border-radius:8px; cursor:pointer}
    .btn.active{background:rgba(79,195,247,.45); box-shadow:0 0 16px rgba(79,195,247,.55) inset}

    .slider{display:flex; align-items:center; gap:8px}
    .slider label{font-size:10px; color:var(--ghost); min-width:112px}
    .slider input[type=range]{flex:1; appearance:none; height:6px; background:rgba(79,195,247,.25); border-radius:10px; outline:none}
    .slider input[type=range]::-webkit-slider-thumb{appearance:none; width:18px; height:18px; border-radius:50%; background:var(--ui); box-shadow:0 0 10px rgba(79,195,247,.8)}
    .val{font-size:11px; min-width:36px; text-align:right; color:var(--ui)}
    .kv{display:flex; align-items:center; gap:8px}
    .kv input[type=color]{width:28px; height:18px; border:1px solid var(--edge); border-radius:6px; background:none}
    select{background:rgba(79,195,247,.12); border:1px solid var(--edge); color:var(--ink); padding:6px 8px; border-radius:8px; font-size:11px}
    input[type=file]{font-size:11px}

    #xfaderWrap{position:relative; padding:8px 10px; border:1px dashed var(--edge); border-radius:8px; display:grid; gap:8px}
    #xfader{width:100%}
    .xf-labels{display:flex; justify-content:space-between; font-size:10px; color:var(--ghost)}

    #mini{ position:fixed; right:14px; bottom:18px; z-index:10; display:none; gap:8px; align-items:center; background:var(--panel); border:1px solid var(--edge); border-radius:999px; padding:8px 10px; font-size:12px; color:var(--ink); box-shadow:0 10px 40px rgba(0,0,0,.55) }
    #mini .dot{width:10px; height:10px; border-radius:50%; background:var(--ui)}

    #diag{font-size:11px; line-height:1.5}
    #diag .pass{color:var(--good)}
    #diag .fail{color:var(--bad)}

    @media (max-width:480px){ .row .btn{min-width:64px; padding:8px} .dock-body{max-height:58vh} }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="infoBadge" class="badge">
    <div style="font-weight:700; color:var(--ui)">Venn Decks</div>
    <div style="font-size:10px; color:var(--ghost)">Geo‚Äëmixing ‚Ä¢ lights ‚Ä¢ EQ</div>
  </div>
  <div id="blendBadge" class="badge">üé® NORMAL</div>
  <div id="viewBadge" class="badge">üìπ FRONT</div>
  <div id="fallbackBadge" class="badge">‚ö†Ô∏è 3D unavailable ‚Äî using 2D fallback</div>

  <div id="dock">
    <div id="dockHeader" class="dock-header">
      <div class="grip"></div>
      <div class="dock-title">DJ Deck Controls</div>
      <div class="dock-actions">
        <button id="minBtn" class="chip">Min</button>
      </div>
    </div>
    <div class="dock-body">
      <details class="section" open>
        <summary>üéöÔ∏è Crossfader & Transport</summary>
        <div class="content">
          <div id="xfaderWrap">
            <div class="xf-labels"><span>A</span><span>Crossfader</span><span>B</span></div>
            <input id="xfader" type="range" min="-100" max="100" value="0">
            <div class="row">
              <div class="slider"><label>Never Overlap</label><input id="noOverlap" type="checkbox"></div>
              <div class="slider"><label>Tempo (BPM)</label><input id="bpm" type="range" min="20" max="240" value="90"><span id="bpmVal" class="val">90</span></div>
              <button class="btn" id="syncPulse">Pulse</button>
              <button class="btn" id="orbit">Orbit</button>
            </div>
          </div>
        </div>
      </details>

      <details class="section" open>
        <summary>üìπ Views & Blend</summary>
        <div class="content">
          <div class="row">
            <button class="btn" data-view="front">Front</button>
            <button class="btn" data-view="top">Top</button>
            <button class="btn" data-view="side">Side</button>
            <button class="btn" data-view="iso">Iso</button>
          </div>
          <div class="row">
            <button class="btn" data-blend="normal">Normal</button>
            <button class="btn" data-blend="add">Add</button>
            <button class="btn" data-blend="multiply">Multiply</button>
            <button class="btn" data-blend="screen">Screen</button>
          </div>
          <div class="row">
            <div class="slider"><label>Overlap Intensity</label><input id="overlapInt" type="range" min="0" max="100" value="80"><span id="overlapIntVal" class="val">80</span></div>
          </div>
        </div>
      </details>

      <details class="section" open>
        <summary>üìê Structure</summary>
        <div class="content">
          <div class="slider"><label>Layers (4‚Äì32)</label><input id="layerRange" type="range" min="4" max="32" value="32"><span id="layerVal" class="val">32</span></div>
          <div class="slider"><label>Separation</label><input id="sepRange" type="range" min="0" max="100" value="40"><span id="sepVal" class="val">40</span></div>
          <div class="slider"><label>Spacing</label><input id="spaceRange" type="range" min="10" max="100" value="50"><span id="spaceVal" class="val">50</span></div>
        </div>
      </details>

      <details class="section" open>
        <summary>üü© Deck A (left)</summary>
        <div class="content">
          <div class="row">
            <div class="kv"><label>Color</label><input id="colA" type="color" value="#00ff88"></div>
            <div class="kv"><label>Light</label><input id="lightColA" type="color" value="#00ff88"></div>
            <div class="slider"><label>Light Intensity</label><input id="lightA" type="range" min="0" max="400" value="200"><span id="lightAVal" class="val">200</span></div>
          </div>
          <div class="row">
            <div class="slider"><label>Opacity</label><input id="opA" type="range" min="5" max="100" value="30"><span id="opAVal" class="val">30</span></div>
            <div class="kv"><label>Material</label><select id="matA"><option>basic</option><option>lambert</option><option>standard</option><option>wireframe</option></select></div>
          </div>
          <div class="row">
            <div class="slider"><label>EQ Low</label><input id="eqAL" type="range" min="0" max="100" value="50"><span class="val" id="eqALVal">50</span></div>
            <div class="slider"><label>EQ Mid</label><input id="eqAM" type="range" min="0" max="100" value="50"><span class="val" id="eqAMVal">50</span></div>
            <div class="slider"><label>EQ High</label><input id="eqAH" type="range" min="0" max="100" value="50"><span class="val" id="eqAHVal">50</span></div>
          </div>
          <div class="row">
            <div class="kv"><label>Texture</label><input id="texA" type="file" accept="image/*"></div>
            <button class="btn" id="clearTexA">Clear</button>
          </div>
        </div>
      </details>

      <details class="section" open>
        <summary>üü• Deck B (right)</summary>
        <div class="content">
          <div class="row">
            <div class="kv"><label>Color</label><input id="colB" type="color" value="#ff4488"></div>
            <div class="kv"><label>Light</label><input id="lightColB" type="color" value="#ff4488"></div>
            <div class="slider"><label>Light Intensity</label><input id="lightB" type="range" min="0" max="400" value="200"><span id="lightBVal" class="val">200</span></div>
          </div>
          <div class="row">
            <div class="slider"><label>Opacity</label><input id="opB" type="range" min="5" max="100" value="30"><span id="opBVal" class="val">30</span></div>
            <div class="kv"><label>Material</label><select id="matB"><option>basic</option><option>lambert</option><option>standard</option><option>wireframe</option></select></div>
          </div>
          <div class="row">
            <div class="slider"><label>EQ Low</label><input id="eqBL" type="range" min="0" max="100" value="50"><span class="val" id="eqBLVal">50</span></div>
            <div class="slider"><label>EQ Mid</label><input id="eqBM" type="range" min="0" max="100" value="50"><span class="val" id="eqBMVal">50</span></div>
            <div class="slider"><label>EQ High</label><input id="eqBH" type="range" min="0" max="100" value="50"><span class="val" id="eqBHVal">50</span></div>
          </div>
          <div class="row">
            <div class="kv"><label>Texture</label><input id="texB" type="file" accept="image/*"></div>
            <button class="btn" id="clearTexB">Clear</button>
          </div>
        </div>
      </details>

      <details class="section">
        <summary>üß™ Diagnostics</summary>
        <div class="content" id="diag">
          <div id="envStatus">Env: <em>checking‚Ä¶</em></div>
          <div id="testResults" style="margin-top:6px"></div>
          <div class="row"><button class="btn" id="runTestsBtn">Run Tests</button></div>
        </div>
      </details>
    </div>
  </div>

  <div id="mini"><span class="dot"></span> Controls</div>

  <script>
  (function(){
    // ---- constants
    const DEFAULTS = { colA:'#00ff88', colB:'#ff4488', overlap:'#ffaa00' };
    const SIZE = 20, MAX_LAYERS = 32;

    // ---- state
    const state = {
      // core
      maxLayers:32, spacing:1.0, dist:20, exploded:false, showA:true, showB:true,
      blend:'normal', overlapIntensity:.8, view:'front', orbit:false, t:0,
      // deck
      xf:0, noOverlap:false, bpm:90, pulse:false,
      // deck A
      colA:DEFAULTS.colA, opA:.3, matA:'basic', eqA:{low:.5,mid:.5,high:.5}, texA:null,
      // deck B
      colB:DEFAULTS.colB, opB:.3, matB:'basic', eqB:{low:.5,mid:.5,high:.5}, texB:null,
      // lights
      lightA:{color:'#00ff88', intensity:2.0},
      lightB:{color:'#ff4488', intensity:2.0},

      // 3D context & objects
      scene:null, camera:null, renderer:null,
      a:[], b:[], o:[],
      lightAObj:null, lightBObj:null,
      using2D:false,
    };

    const canvas = document.getElementById('c');
    const blendBadge = document.getElementById('blendBadge');
    const viewBadge = document.getElementById('viewBadge');
    const fallbackBadge = document.getElementById('fallbackBadge');

    // ---- loader
    async function ensureThree(){
      if(window.THREE) return true;
      const cdns = [
        'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js',
        'https://unpkg.com/three@0.152.2/build/three.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js'
      ];
      for(const src of cdns){
        try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.defer=true; s.onload=()=>res(); s.onerror=rej; document.head.appendChild(s); }); if(window.THREE) return true; }catch(e){}
      }
      return false;
    }

    // ---- math helpers
    function computeOverlapWidth(dist){
      const half = SIZE/2; const left = Math.max(-dist-half, dist-half); const right = Math.min(-dist+half, dist+half); return Math.max(0, right-left);
    }
    function xfGains(xf){ // xf in [-1,1]
      const a = (1-xf)/2; const b = (1+xf)/2; return {a,b};
    }
    function bandWeights(t){ // t in [0,1] bottom->top
      const tri=(c,w)=>Math.max(0,1-Math.abs(t-c)/w);
      return { low:tri(0.0,0.34), mid:tri(0.5,0.34), high:tri(1.0,0.34) };
    }
    function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }

    // ---- tests
    function runTests(){
      const cases = [
        {dist:20, expect:0}, {dist:0, expect:20}, {dist:5, expect:10}, {dist:10, expect:0}, {dist:30, expect:0}
      ];
      const xfCases = [ {xf:-1, e:{a:1,b:0}}, {xf:0, e:{a:.5,b:.5}}, {xf:1, e:{a:0,b:1}} ];
      const out=[];
      for(const t of cases){ const got=Math.round(computeOverlapWidth(t.dist)); out.push(`<div>overlap(dist=${t.dist})=${got} ‚Üí <b class="${got===t.expect?'pass':'fail'}">${got===t.expect?'PASS':'FAIL expected '+t.expect}</b></div>`); }
      for(const t of xfCases){ const g=xfGains(t.xf); const ok=Math.abs(g.a-t.e.a)<1e-6 && Math.abs(g.b-t.e.b)<1e-6; out.push(`<div>xf=${t.xf} ‚Üí a=${g.a.toFixed(2)}, b=${g.b.toFixed(2)} : <b class="${ok?'pass':'fail'}">${ok?'PASS':'FAIL'}</b></div>`); }
      document.getElementById('testResults').innerHTML = out.join('');
    }

    // ---- 2D fallback (minimal but interactive)
    function setup2D(){ state.using2D=true; fallbackBadge.style.display='block'; resize2D(); draw2D(); addEventListener('resize', resize2D); wireUI(); addDockDrag(); }
    function resize2D(){ const dpr=Math.min(2, devicePixelRatio||1); canvas.width=innerWidth*dpr; canvas.height=innerHeight*dpr; canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); }
    function blend2d(mode){ switch(mode){ case 'add': return 'lighter'; case 'multiply': return 'multiply'; case 'screen': return 'screen'; default: return 'source-over'; } }
    function draw2D(){ const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,innerWidth,innerHeight); const w=innerWidth, h=innerHeight; const boxW=Math.min(320, w-48); const cubeH=SIZE*state.spacing; const step=cubeH/Math.max(1,state.maxLayers-1); const cx=w/2; const gains=xfGains(state.xf); const minDist=state.noOverlap? SIZE/2+0.1 : 0; const dist=Math.max(state.dist, minDist); const cxA=cx - dist; const cxB=cx + dist; const left=Math.max(cxA - boxW/2, cxB - boxW/2); const right=Math.min(cxA + boxW/2, cxB + boxW/2); const ow=Math.max(0, right-left);
      for(let i=0;i<state.maxLayers;i++){ const y=h/2 - cubeH/2 + i*step; const t=i/(state.maxLayers-1); const wts=bandWeights(t);
        if(state.showA){ ctx.globalAlpha = gains.a * state.opA * ((.5*state.eqA.low*wts.low + .5*state.eqA.mid*wts.mid + .5*state.eqA.high*wts.high) + .5); ctx.globalCompositeOperation='source-over'; ctx.fillStyle=state.colA; ctx.fillRect(cxA - boxW/2, y, boxW, 2); }
        if(state.showB){ ctx.globalAlpha = gains.b * state.opB * ((.5*state.eqB.low*wts.low + .5*state.eqB.mid*wts.mid + .5*state.eqB.high*wts.high) + .5); ctx.globalCompositeOperation='source-over'; ctx.fillStyle=state.colB; ctx.fillRect(cxB - boxW/2, y, boxW, 2); }
        if(!state.exploded && !state.noOverlap && state.showA && state.showB && ow>0){ ctx.globalAlpha = Math.max(.15,.3*state.overlapIntensity)*(gains.a+gains.b); ctx.globalCompositeOperation=blend2d(state.blend); ctx.fillStyle=DEFAULTS.overlap; ctx.fillRect(left,y,ow,2); }
      }
      ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over'; ctx.strokeStyle='rgba(79,195,247,.25)'; ctx.strokeRect(cx-boxW/2, h/2-cubeH/2, boxW, cubeH);
    }

    // ---- 3D
    function setView(v){ state.view=v; state.orbit=(v==='orbit'); const V={front:[0,0,80], top:[0,80,0], side:[80,0,0], iso:[60,50,60]}; if(state.camera && V[v]){ state.camera.position.set(...V[v]); state.camera.lookAt(0,0,0); } viewBadge.textContent='üìπ '+v.toUpperCase(); }
    function setBlend3D(mat,T){ switch(state.blend){ case 'add': mat.blending=T.AdditiveBlending; break; case 'multiply': mat.blending=T.MultiplyBlending; break; case 'screen': mat.blending=T.CustomBlending; mat.blendEquation=T.AddEquation; mat.blendSrc=T.OneFactor; mat.blendDst=T.OneMinusSrcColorFactor; break; default: mat.blending=T.NormalBlending; } }

    function buildMaterials(T, deck){
      const type = state[deck==='A'?'matA':'matB'];
      const wire = type==='wireframe';
      const ctor = type==='lambert'? T.MeshLambertMaterial : type==='standard'? T.MeshStandardMaterial : T.MeshBasicMaterial;
      const color = deck==='A'? state.colA : state.colB;
      const opacity = (deck==='A'? state.opA : state.opB);
      const mat = new ctor({ color, transparent:true, opacity, wireframe:wire, side:T.DoubleSide, depthWrite:false });
      const map = deck==='A'? state.texA : state.texB; if(map){ mat.map = map; mat.needsUpdate=true; }
      setBlend3D(mat,T); return mat;
    }

    function rebuildDeckMaterials(T, deck){ const arr = deck==='A'? state.a : state.b; for(const g of arr){ const m = buildMaterials(T, deck); g.userData.plane.material.dispose?.(); g.userData.plane.material = m; }
      // update light
      const lightObj = deck==='A'? state.lightAObj : state.lightBObj; if(lightObj){ const cfg = deck==='A'? state.lightA : state.lightB; const rgb=hexToRgb(cfg.color); lightObj.color = new T.Color(rgb.r/255,rgb.g/255,rgb.b/255); lightObj.intensity = cfg.intensity/100; }
    }

    function layerGroup(T,colorHex, base){ const g=new T.Group(); const half=SIZE/2; const color=new T.Color(colorHex);
      const pts=[new T.Vector3(-half,0,-half),new T.Vector3(half,0,-half),new T.Vector3(half,0,half),new T.Vector3(-half,0,half),new T.Vector3(-half,0,-half)];
      const line=new T.Line(new T.BufferGeometry().setFromPoints(pts), new T.LineBasicMaterial({color,transparent:true,opacity:base*.9})); g.add(line);
      const plane=new T.Mesh(new T.PlaneGeometry(SIZE,SIZE), buildMaterials(T, colorHex===state.colA?'A':'B')); plane.rotation.x=-Math.PI/2; g.add(plane);
      const dotGeo=new T.SphereGeometry(.38,10,10); const dotMat=new T.MeshBasicMaterial({color,transparent:true,opacity:base*1.1});
      for(const [x,z] of [[-half,-half],[half,-half],[half,half],[-half,half]]){ const dot=new T.Mesh(dotGeo,dotMat); dot.position.set(x,0,z); g.add(dot); }
      g.userData={plane, baseOpacity:base}; return g;
    }

    function overlapGroup(T){ const g=new T.Group(); const plane=new T.Mesh(new T.PlaneGeometry(1,SIZE), new T.MeshBasicMaterial({color:DEFAULTS.overlap,transparent:true,opacity:0,side:T.DoubleSide,depthWrite:false})); plane.rotation.x=-Math.PI/2; g.add(plane); const line=new T.Line(new T.BufferGeometry().setFromPoints([new T.Vector3(-.5,0,-SIZE/2),new T.Vector3(.5,0,-SIZE/2),new T.Vector3(.5,0,SIZE/2),new T.Vector3(-.5,0,SIZE/2),new T.Vector3(-.5,0,-SIZE/2)]), new T.LineBasicMaterial({color:DEFAULTS.overlap,transparent:true,opacity:.6})); g.add(line); g.userData={plane,line}; return g; }

    function computeEQGain(deck, t){ const w=bandWeights(t); const eq=deck==='A'?state.eqA:state.eqB; return (0.5*eq.low*w.low + 0.5*eq.mid*w.mid + 0.5*eq.high*w.high) + 0.5; }

    function updateLayout3D(){ const T=window.THREE; const h=SIZE*state.spacing; const step=h/Math.max(1,state.maxLayers-1); const gains=xfGains(state.xf); const minDist = state.noOverlap? SIZE/2+0.1 : 0; const dist=Math.max(state.dist, minDist); const overlapW = state.noOverlap? 0 : computeOverlapWidth(dist);
      for(let i=0;i<MAX_LAYERS;i++){
        const vis=i<state.maxLayers; const y=-h/2+i*step; const t=i/(state.maxLayers-1);
        const A=state.a[i], B=state.b[i], O=state.o[i];
        if(A){ A.visible=vis && state.showA; if(A.visible){ A.position.set(-dist + (state.exploded? (state.maxLayers/2 - i)*-2 : 0), y, 0); const m=A.userData.plane.material; setBlend3D(m,T); m.opacity = state.opA * gains.a * computeEQGain('A',t); m.color = new T.Color(state.colA); if(state.texA){ m.map=state.texA; m.needsUpdate=true; } else { m.map=null; m.needsUpdate=true; } } }
        if(B){ B.visible=vis && state.showB; if(B.visible){ B.position.set( dist + (state.exploded? (state.maxLayers/2 - i)* 2 : 0), y, 0); const m=B.userData.plane.material; setBlend3D(m,T); m.opacity = state.opB * gains.b * computeEQGain('B',t); m.color = new T.Color(state.colB); if(state.texB){ m.map=state.texB; m.needsUpdate=true; } else { m.map=null; m.needsUpdate=true; } } }
        if(O){ const showO=vis && !state.exploded && overlapW>0 && state.showA && state.showB; O.visible=showO; if(showO){ const left=Math.max(-dist - SIZE/2, dist - SIZE/2); const right=Math.min(-dist + SIZE/2, dist + SIZE/2); const cx=(left+right)/2; O.position.set(cx,y,0); O.children[0].scale.set(overlapW,1,1); O.children[1].scale.set(overlapW,1,1); const mat=O.userData.plane.material; setBlend3D(mat,T); mat.opacity = Math.max(.15,.3*state.overlapIntensity)*(gains.a+gains.b); O.children[1].material.opacity = state.pulse? .9 : .6; } }
      }
      // lights
      if(state.lightAObj){ const rgb=hexToRgb(state.lightA.color); state.lightAObj.color=new T.Color(rgb.r/255,rgb.g/255,rgb.b/255); state.lightAObj.intensity=state.lightA.intensity/100; }
      if(state.lightBObj){ const rgb=hexToRgb(state.lightB.color); state.lightBObj.color=new T.Color(rgb.r/255,rgb.g/255,rgb.b/255); state.lightBObj.intensity=state.lightB.intensity/100; }
    }

    function animate3D(){ requestAnimationFrame(animate3D); const T=window.THREE; const t=performance.now()/1000; state.t+=.01; const beat = state.pulse? (0.5+0.5*Math.sin(2*Math.PI*(state.bpm/60)*t)) : 1.0; if(state.orbit && state.camera){ const r=80; state.camera.position.x=Math.sin(state.t*.3)*r; state.camera.position.z=Math.cos(state.t*.3)*r; state.camera.position.y=50+Math.sin(state.t*.2)*10; state.camera.lookAt(0,0,0); }
      // pulsing opacity subtly on beat
      if(state.a.length){ for(let i=0;i<state.maxLayers;i++){ const A=state.a[i]; if(A?.visible){ A.userData.plane.material.opacity *= (0.95 + 0.1*beat); } const B=state.b[i]; if(B?.visible){ B.userData.plane.material.opacity *= (0.95 + 0.1*beat); } } }
      if(state.renderer && state.scene && state.camera) state.renderer.render(state.scene,state.camera);
    }

    // ---- UI
    function vibr(ms=12){ if(navigator.vibrate) navigator.vibrate(ms); }
    function wireUI(){
      const vBtns=document.querySelectorAll('[data-view]'); vBtns.forEach(b=>b.addEventListener('click',()=>{ vBtns.forEach(x=>x.classList.remove('active')); b.classList.add('active'); setView(b.dataset.view); vibr(12);})); document.querySelector('[data-view="front"]').classList.add('active');
      const blBtns=document.querySelectorAll('[data-blend]'); blBtns.forEach(b=>b.addEventListener('click',()=>{ blBtns.forEach(x=>x.classList.remove('active')); b.classList.add('active'); state.blend=b.dataset.blend; blendBadge.textContent='üé® '+state.blend.toUpperCase(); vibr(10); if(!state.using2D) updateLayout3D(); else draw2D(); })); document.querySelector('[data-blend="normal"]').classList.add('active');
      const bind=(id,fn)=>{ const el=document.getElementById(id); const valEl=document.getElementById(id+'Val'); if(!el) return; const upd=(e)=>{ const v = (el.type==='checkbox')? el.checked : (el.type==='range'? Number(el.value) : el.value); fn(v); if(valEl) valEl.textContent = (typeof v==='number'? Math.round(v): v); if(!state.using2D) updateLayout3D(); else draw2D(); }; el.addEventListener('input', upd); el.addEventListener('change', upd); upd(); };

      // Crossfader / transport
      bind('xfader', v=> state.xf = v/100 );
      bind('noOverlap', v=> state.noOverlap = !!v );
      bind('bpm', v=> state.bpm = v );
      document.getElementById('syncPulse').addEventListener('click', ()=>{ state.pulse=!state.pulse; document.getElementById('syncPulse').classList.toggle('active'); vibr(15); });
      document.getElementById('orbit').addEventListener('click', ()=>{ state.orbit=!state.orbit; document.getElementById('orbit').classList.toggle('active'); vibr(15); });

      // Structure
      bind('overlapInt', v=> state.overlapIntensity=v/100 );
      bind('layerRange', v=> state.maxLayers=v );
      bind('sepRange', v=> state.dist = 10 + (v/100)*40 );
      bind('spaceRange', v=> state.spacing = .5 + (v/100)*1.5 );

      // Deck A
      bind('opA', v=> state.opA = v/100 );
      document.getElementById('colA').addEventListener('input', e=>{ state.colA=e.target.value; (!state.using2D? rebuildDeckMaterials(THREE,'A'):0); updateLayout3D(); });
      document.getElementById('matA').addEventListener('change', e=>{ state.matA=e.target.value; (!state.using2D? rebuildDeckMaterials(THREE,'A'):0); updateLayout3D(); });
      ['eqAL','eqAM','eqAH'].forEach((id,i)=> bind(id, v=>{ const key=['low','mid','high'][i]; state.eqA[key]=v/100; }));
      bind('lightA', v=> state.lightA.intensity=v );
      document.getElementById('lightColA').addEventListener('input', e=>{ state.lightA.color=e.target.value; updateLayout3D(); });
      document.getElementById('texA').addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); const loader=new THREE.TextureLoader(); loader.load(url, tex=>{ tex.wrapS=tex.wrapT=THREE.RepeatWrapping; state.texA=tex; rebuildDeckMaterials(THREE,'A'); updateLayout3D(); }); });
      document.getElementById('clearTexA').addEventListener('click', ()=>{ state.texA=null; rebuildDeckMaterials(THREE,'A'); updateLayout3D(); });

      // Deck B
      bind('opB', v=> state.opB = v/100 );
      document.getElementById('colB').addEventListener('input', e=>{ state.colB=e.target.value; (!state.using2D? rebuildDeckMaterials(THREE,'B'):0); updateLayout3D(); });
      document.getElementById('matB').addEventListener('change', e=>{ state.matB=e.target.value; (!state.using2D? rebuildDeckMaterials(THREE,'B'):0); updateLayout3D(); });
      ['eqBL','eqBM','eqBH'].forEach((id,i)=> bind(id, v=>{ const key=['low','mid','high'][i]; state.eqB[key]=v/100; }));
      bind('lightB', v=> state.lightB.intensity=v );
      document.getElementById('lightColB').addEventListener('input', e=>{ state.lightB.color=e.target.value; updateLayout3D(); });
      document.getElementById('texB').addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); const loader=new THREE.TextureLoader(); loader.load(url, tex=>{ tex.wrapS=tex.wrapT=THREE.RepeatWrapping; state.texB=tex; rebuildDeckMaterials(THREE,'B'); updateLayout3D(); }); });
      document.getElementById('clearTexB').addEventListener('click', ()=>{ state.texB=null; rebuildDeckMaterials(THREE,'B'); updateLayout3D(); });

      // Minimize dock
      const dock=document.getElementById('dock'); const mini=document.getElementById('mini');
      document.getElementById('minBtn').addEventListener('click', ()=>{ dock.style.display='none'; mini.style.display='flex'; vibr(10); });
      mini.addEventListener('click', ()=>{ dock.style.display='block'; mini.style.display='none'; vibr(10); });

      // Diagnostics
      document.getElementById('runTestsBtn').addEventListener('click', runTests); runTests();
    }

    // draggable dock
    function addDockDrag(){ const dock=document.getElementById('dock'); const head=document.getElementById('dockHeader'); let sx=0,sy=0,ox=0,oy=0,drag=false; const start=(x,y)=>{drag=true; sx=x;sy=y; const r=dock.getBoundingClientRect(); ox=r.left; oy=r.top;}; const move=(x,y)=>{ if(!drag)return; const nx=ox+(x-sx), ny=oy+(y-sy); dock.style.left=nx+'px'; dock.style.top=ny+'px'; dock.style.right='unset'; dock.style.bottom='unset'; }; const end=()=>{drag=false;}; head.addEventListener('pointerdown',e=>{ head.setPointerCapture(e.pointerId); start(e.clientX,e.clientY); }); head.addEventListener('pointermove',e=>move(e.clientX,e.clientY)); head.addEventListener('pointerup',end); head.addEventListener('pointercancel',end); }

    // camera drag
    function addDrag3D(){ canvas.addEventListener('touchstart', (e)=>{ state.drag=true; state.tx=e.touches[0].clientX; state.ty=e.touches[0].clientY; }, {passive:true}); canvas.addEventListener('touchmove', (e)=>{ if(state.orbit) return; const nx=e.touches[0].clientX, ny=e.touches[0].clientY; const dx=nx-(state.tx||nx), dy=ny-(state.ty||ny); const p=state.camera.position; const d=Math.hypot(p.x,p.y,p.z); let th=Math.atan2(p.x,p.z) - dx*0.005; let ph=Math.acos(p.y/d) - dy*0.005; ph=Math.max(0.1, Math.min(Math.PI-0.1, ph)); state.camera.position.x=d*Math.sin(ph)*Math.sin(th); state.camera.position.y=d*Math.cos(ph); state.camera.position.z=d*Math.sin(ph)*Math.cos(th); state.camera.lookAt(0,0,0); state.tx=nx; state.ty=ny; }, {passive:true}); }

    // boot
    async function boot(){ document.getElementById('envStatus').textContent='Env: loading three.js‚Ä¶'; const ok=await ensureThree(); if(!ok){ document.getElementById('envStatus').innerHTML='Env: <b class="fail">three.js unavailable</b>'; setup2D(); return; }
      const T=window.THREE; document.getElementById('envStatus').innerHTML='Env: <b class="pass">three.js loaded</b>';
      state.scene=new T.Scene(); state.scene.background=new T.Color(0x000000); state.scene.fog=new T.FogExp2(0x000000,.003);
      state.camera=new T.PerspectiveCamera(50, innerWidth/innerHeight, .1, 1000); setView('front');
      state.renderer=new T.WebGLRenderer({canvas, antialias:true}); state.renderer.setSize(innerWidth,innerHeight); state.renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
      // lights
      const makeLight=(hex)=>{ const {r,g,b}=hexToRgb(hex); return new T.PointLight(new T.Color(r/255,g/255,b/255), 2, 150); };
      state.lightAObj=makeLight(state.lightA.color); state.lightAObj.position.set(-40,20,30); state.scene.add(state.lightAObj);
      state.lightBObj=makeLight(state.lightB.color); state.lightBObj.position.set( 40,20,30); state.scene.add(state.lightBObj);
      state.scene.add(new T.AmbientLight(0xffffff,.4)); const top=new T.DirectionalLight(0xffffff,.7); top.position.set(0,80,0); state.scene.add(top);
      // layers
      for(let i=0;i<MAX_LAYERS;i++){ const base=.85-(i/MAX_LAYERS)*.6; const A=layerGroup(T,state.colA,base); const B=layerGroup(T,state.colB,base); const O=overlapGroup(T); state.a.push(A); state.b.push(B); state.o.push(O); state.scene.add(A,B,O); }
      addEventListener('resize', ()=>{ state.camera.aspect=innerWidth/innerHeight; state.camera.updateProjectionMatrix(); state.renderer.setSize(innerWidth,innerHeight); });
      addDrag3D();
      wireUI(); addDockDrag();
      updateLayout3D(); requestAnimationFrame(animate3D);
    }

    boot();
  })();
  </script>
</body>
</html>

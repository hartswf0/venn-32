<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VOL‑MEDIA DECKS v4 — Stacks of Stacks</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;touch-action:none}
  html,body{height:100%}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#000;color:#fff;overflow:hidden}
  #canvas{width:100vw;height:100vh;display:block}
  #toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.85);border:1px solid rgba(255,255,255,.2);padding:6px 10px;border-radius:10px;font-size:12px;color:#fff;z-index:6;display:none}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="toast"></div>
<script>
(async function(){
  // ---- Load THREE safely if absent
  if(!window.THREE){
    const CDNs=['https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js','https://unpkg.com/three@0.152.2/build/three.min.js','https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'];
    for(const src of CDNs){ try{ await new Promise((res,rej)=>{const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s)}); if(window.THREE) break; }catch(e){} }
  }

  // ===== Scene =====
  const canvas=document.getElementById('canvas');
  const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
  const camera=new THREE.PerspectiveCamera(54, innerWidth/innerHeight, .1, 3000); camera.position.set(80,56,96); camera.lookAt(0,12,0);
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true}); renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight)});

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff,.22));
  const key=new THREE.PointLight(0x66ddff,1.6,520); key.position.set(0,70,120); scene.add(key);
  const warm=new THREE.PointLight(0xffaa66,1.1,460); warm.position.set(90,52,-60); scene.add(warm);
  const rim=new THREE.DirectionalLight(0xffffff,.55); rim.position.set(-80,110,-40); scene.add(rim);

  // ===== State =====
  const CRATES=[
    {id:'70s', name:'1970s', col:0xffa44d, voice:'tape'},
    {id:'80s', name:'1980s', col:0x59e0ff, voice:'fm'},
    {id:'90s', name:'1990s', col:0x7da1ff, voice:'breaks'},
    {id:'00s', name:'2000s', col:0xffffff, voice:'supersaw'},
    {id:'10s', name:'2010s', col:0x00d4aa, voice:'trap'},
    {id:'20s', name:'2020s', col:0xc47dff, voice:'neural'}
  ];

  const decks={
    A:{color:0x00ff88, crate:CRATES[1], steps:16, root:110, scale:'minorPent', spacing:1.12, layers:16, size:1.0, seq:Array(32).fill(0), tune:Array(32).fill(0), phase:0, group:null, plates:[], subs:{}},
    B:{color:0xff4488, crate:CRATES[3], steps:16, root:220, scale:'majorPent', spacing:1.12, layers:16, size:1.0, seq:Array(32).fill(0), tune:Array(32).fill(0), phase:0, group:null, plates:[], subs:{}}
  };

  // Global engine & camera vars
  let bpm=112, energy=.45, resonance=.5, playing=false, xf=0; // xf -1..+1 (A..B)
  let AC, master, voices={A:null,B:null}; let voicesReady=false;
  let phi=0.8, theta=0.9, dist=120, orbit=false, tOrbit=0;

  const MAX_PLATES=28, SIZE=12;

  // ===== Base builders =====
  function mkPlate(color,op){ const g=new THREE.PlaneGeometry(SIZE,SIZE); const m=new THREE.MeshStandardMaterial({color,transparent:true,opacity:op,side:THREE.DoubleSide,depthWrite:false,roughness:.55,metalness:.08}); const mesh=new THREE.Mesh(g,m); mesh.rotation.x=-Math.PI/2; m.emissive=new THREE.Color(color); m.emissiveIntensity=.22; return mesh; }
  function mkSprite(text){ const cvs=document.createElement('canvas'); const s=256; cvs.width=cvs.height=s; const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,s,s); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s); ctx.fillStyle='white'; ctx.font='bold 48px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=12; ctx.fillText(text,s/2,s/2); const tex=new THREE.CanvasTexture(cvs); const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false}); const spr=new THREE.Sprite(mat); spr.scale.set(8,8,1); return spr; }
  function updateSpriteText(sprite,txt){ const t = sprite.material.map.image; const ctx=t.getContext('2d'); const s=t.width; ctx.clearRect(0,0,s,s); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s); ctx.fillStyle='#ffffff'; ctx.font='bold 48px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.7)'; ctx.shadowBlur=14; ctx.fillText(txt,s/2,s/2); sprite.material.map.needsUpdate=true; }

  // ===== Primary Decks =====
  let sepX=30; // half-distance between stacks
  function buildDeck(which, x){ const d=decks[which]; if(d.group){ scene.remove(d.group); d.plates.forEach(p=>{p.geometry.dispose?.(); p.material.dispose?.();}); d.plates.length=0; }
    const g=new THREE.Group(); g.position.set(x,0,0);
    for(let i=0;i<MAX_PLATES;i++){ const base=.9-(i/MAX_PLATES)*.55; const p=mkPlate(d.color,Math.max(.22,base*.5)); p.position.y=i*d.spacing; g.add(p); d.plates.push(p); }
    // deck tag
    const tag=mkSprite(which); tag.position.set(0,2,0); g.add(tag); d.subs.tag=tag;
    scene.add(g); d.group=g; refreshDeckVisual(which,true);
  }
  buildDeck('A',-sepX); buildDeck('B',sepX);

  function refreshDeckVisual(which){ const d=decks[which]; const activeColor=new THREE.Color(d.color).lerp(new THREE.Color(0xffffff), 0.3*resonance);
    const baseScale=d.size*(1+0.06*energy); const EI=0.18+0.6*energy; const OP=0.3+0.6*energy; d.plates.forEach((p,i)=>{
      const vis=i<d.layers; p.visible=vis; if(!vis) return; p.position.y=i*d.spacing; p.scale.set(baseScale,1,baseScale);
      p.material.color.copy(activeColor); p.material.emissive.copy(new THREE.Color(d.color));
      p.material.emissiveIntensity = EI*(0.95 - (i/Math.max(1,d.layers))*0.5);
      p.material.opacity = OP*(0.95 - (i/Math.max(1,d.layers))*0.4);
    });
  }
  function applySeparation(){ decks.A.group.position.x=-sepX; decks.B.group.position.x=sepX; controlShelf.group.position.x=0; overlap.group.position.x=0; cameraWall.group.position.x=0; }
  function applyAll(){ refreshDeckVisual('A'); refreshDeckVisual('B'); refreshOverlapVisual(); refreshControlShelf(); refreshCameraWall(); applySeparation(); }

  // ===== Overlap musical stack =====
  const overlap={color:0xffaa00, steps:16, spacing:1.12, layers:12, seq:Array(32).fill(0), tune:Array(32).fill(0), phase:0, group:null, plates:[]};
  (function buildOverlap(){ const g=new THREE.Group(); g.position.set(0,0,0); overlap.group=g; for(let i=0;i<MAX_PLATES;i++){ const p=mkPlate(overlap.color, .16); p.position.y=i*overlap.spacing; g.add(p); overlap.plates.push(p);} scene.add(g); refreshOverlapVisual(); })();
  function refreshOverlapVisual(){ const EI=.12+.5*energy; const OP=.18+.5*energy; for(let i=0;i<overlap.plates.length;i++){ const p=overlap.plates[i]; const vis=i<overlap.layers; p.visible=vis; if(!vis) continue; p.position.y=i*overlap.spacing; p.material.emissiveIntensity = EI*(0.95 - (i/Math.max(1,overlap.layers))*0.5); p.material.opacity = OP*(0.95 - (i/Math.max(1,overlap.layers))*0.4); } }

  // ===== Control Shelf (Stacks-as-Sliders) =====
  // Pull up in the center to reveal a shelf of vertical control stacks (BPM, Energy, Res, Mix)
  const controlShelf={group:new THREE.Group(), shown:false, yHidden:-22, yShown:2, stacks:[]};
  scene.add(controlShelf.group);
  function buildControlShelf(){ const defs=[
      {name:'BPM', color:0x59e0ff, getter:()=>bpm, setter:v=>{ bpm=clamp(Math.round(v),60,180); }, min:60, max:180},
      {name:'ENERGY', color:0x00ff88, getter:()=>energy*100, setter:v=>{ energy=clamp(v/100,0,1) }, min:0, max:100},
      {name:'RES', color:0xffa44d, getter:()=>resonance*100, setter:v=>{ resonance=clamp(v/100,0,1) }, min:0, max:100},
      {name:'MIX', color:0xff4488, getter:()=>((xf+1)/2)*100, setter:v=>{ setXF((clamp(v,0,100)/100)*2-1) }, min:0, max:100}
    ];
    const spacingX=14;
    defs.forEach((d,i)=>{ const g=new THREE.Group(); g.position.set((i-1.5)*spacingX, controlShelf.yHidden, 0); // base column of plates
      const plates=[]; const N=16; for(let j=0;j<N;j++){ const p=mkPlate(d.color, 0.22); p.position.y=j*1.2; g.add(p); plates.push(p); }
      // label sprite
      const tag=mkSprite(d.name); tag.position.set(0, N*1.2+2, 0); g.add(tag);
      controlShelf.group.add(g); controlShelf.stacks.push({def:d, group:g, plates, tag});
    });
  }
  buildControlShelf();
  function refreshControlShelf(){ controlShelf.stacks.forEach(S=>{ const v=clamp((S.def.getter()-S.def.min)/(S.def.max-S.def.min),0,1); const nOn=Math.round(v*S.plates.length); S.plates.forEach((p,idx)=>{ p.visible=true; p.material.opacity = idx<nOn? 0.65 : 0.12; p.material.emissiveIntensity = idx<nOn? 0.85 : 0.15; p.scale.set(1+(idx<nOn?0.08:0),1,1+(idx<nOn?0.08:0)); }); });
    controlShelf.group.position.y = controlShelf.shown ? controlShelf.yShown : controlShelf.yHidden; }

  // ===== Camera Wall (Stacks control camera/orbit) =====
  const cameraWall={group:new THREE.Group(), stacks:[]}; scene.add(cameraWall.group);
  const VIEWS=[ {name:'FRONT',pos:[0,34,110]}, {name:'ISO L',pos:[-85,42,70]}, {name:'ISO R',pos:[85,42,70]}, {name:'SIDE',pos:[0,36,-110]}, {name:'TOP',pos:[0,130,0.01]} ];
  let viewIdx=1; function applyView(){ const v=VIEWS[viewIdx%VIEWS.length]; camera.position.set(...v.pos); camera.lookAt(0,12,0); showViewLabel(v.name); }
  const viewLabel=mkSprite(''); viewLabel.position.set(0, MAX_PLATES*1.2 + 16, 0); scene.add(viewLabel);
  function showViewLabel(txt){ updateSpriteText(viewLabel, txt); clearTimeout(showViewLabel._id); showViewLabel._id=setTimeout(()=>{ updateSpriteText(viewLabel,'') }, 900); }

  function buildCameraWall(){ const defs=[
    {name:'ORBIT', color:0x9ad7ff, getter:()=>orbit?60:0, setter:v=>{ orbit = v>30; }, min:0, max:60},
    {name:'SPEED', color:0xc47dff, getter:()=>Math.round( (dist-60) ), setter:v=>{ dist=clamp(60+v,60,180); }, min:0, max:120},
    {name:'VIEW', color:0x00d4aa, getter:()=>viewIdx*20, setter:v=>{ viewIdx=Math.round(clamp(v/20,0,VIEWS.length-1)); applyView(); }, min:0, max: (VIEWS.length-1)*20 }
  ];
  const spacingX=16; defs.forEach((d,i)=>{ const g=new THREE.Group(); g.position.set((i-1)*spacingX, 0, -60); const plates=[]; const N=12; for(let j=0;j<N;j++){ const p=mkPlate(d.color, .18); p.position.y=j*1.4; g.add(p); plates.push(p);} const tag=mkSprite(d.name); tag.position.set(0,N*1.4+2,0); g.add(tag); cameraWall.group.add(g); cameraWall.stacks.push({def:d,group:g,plates,tag}); }); }
  buildCameraWall();
  function refreshCameraWall(){ cameraWall.stacks.forEach(S=>{ const v=clamp((S.def.getter()-S.def.min)/(S.def.max-S.def.min),0,1); const nOn=Math.round(v*S.plates.length); S.plates.forEach((p,idx)=>{ p.visible=true; p.material.opacity = idx<nOn? 0.55 : 0.12; p.material.emissiveIntensity = idx<nOn? 0.7 : 0.12; }); }); }

  // ===== Gestures =====
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pickAt(clientX,clientY,objects){ v2.x=(clientX/innerWidth)*2-1; v2.y=-(clientY/innerHeight)*2+1; ray.setFromCamera(v2,camera); return ray.intersectObjects(objects); }

  // 1) Deck gestures (tap / tune / spacing / crossfade / pinch for layers & size)
  let dragging=false, activeDeck=null, mode=null, start={x:0,y:0}, hold=false, tuneIdx=null;
  canvas.addEventListener('pointerdown',ev=>{
    const hits=pickAt(ev.clientX,ev.clientY,[...decks.A.plates,...decks.B.plates]);
    if(!hits.length){ // maybe control stacks or camera wall
      const csHits=pickAt(ev.clientX,ev.clientY, controlShelf.group.children.flatMap(g=>g.children).filter(o=>o.isMesh));
      if(csHits.length){ beginControlShelfDrag(csHits[0].object, ev.clientY); return; }
      const camHits=pickAt(ev.clientX,ev.clientY, cameraWall.group.children.flatMap(g=>g.children).filter(o=>o.isMesh));
      if(camHits.length){ beginCameraWallDrag(camHits[0].object, ev.clientY); return; }
      // background: maybe toggle shelf by swipe
      beginBackgroundGesture(ev.clientX,ev.clientY);
      return;
    }
    const mesh=hits[0].object; const which = decks.A.plates.includes(mesh)?'A':'B'; activeDeck=which; dragging=true; start.x=ev.clientX; start.y=ev.clientY; hold=true; tuneIdx=(which==='A'?decks.A.plates.indexOf(mesh):decks.B.plates.indexOf(mesh));
    setTimeout(()=>{ if(hold){ mode='tune'; showTuner(which,tuneIdx,0); if(navigator.vibrate) navigator.vibrate(7); } },280);
  });
  canvas.addEventListener('pointermove',ev=>{
    if(!dragging||!activeDeck) return; const dx=ev.clientX-start.x; const dy=ev.clientY-start.y; const d=decks[activeDeck];
    if(mode==='tune'){
      const st=clamp(Math.round(-dy/12),-12,12); setTune(activeDeck,tuneIdx,st); showTuner(activeDeck,tuneIdx,st); previewTone(activeDeck,tuneIdx,st);
    } else {
      hold=false;
      if(Math.abs(dy)>Math.abs(dx)){
        d.spacing = clamp(d.spacing + (-dy)*0.002, 0.6, 2.0); start.y=ev.clientY; refreshDeckVisual(activeDeck);
      } else {
        setXF(xf + dx*0.004); start.x=ev.clientX;
      }
    }
  });
  addEventListener('pointerup',ev=>{
    if(dragging&&activeDeck){ if(mode==='tune'){ hideTuner(); } else { const d=decks[activeDeck]; const step=tuneIdx % d.steps; d.seq[step]=d.seq[step]?0:1; pulsePlate((activeDeck==='A'?decks.A.plates:decks.B.plates)[tuneIdx]); click(); } }
    dragging=false; activeDeck=null; hold=false; mode=null; tuneIdx=null;
  });
  // pinch gestures
  let two=null; addEventListener('touchstart',e=>{ if(e.touches.length===2){ const a=pickStack(e.touches[0]); const b=pickStack(e.touches[1]); if(a && b && a.which===b.which){ two={type:'layers', which:a.which, d:dist2(e.touches), baseLayers:decks[a.which].layers, baseSize:decks[a.which].size}; } else if(a && b){ two={type:'sep', base:sepX, x:(e.touches[0].clientX+e.touches[1].clientX)/2}; } else { two=null; } } });
  addEventListener('touchmove',e=>{ if(!two||e.touches.length!==2) return; if(two.type==='layers'){ const k=dist2(e.touches)/two.d; const w=two.which; decks[w].layers = clamp(Math.round(two.baseLayers*k),6,MAX_PLATES); decks[w].size = clamp(two.baseSize*k,0.7,1.6); refreshDeckVisual(w); } else if(two.type==='sep'){ const nx=(e.touches[0].clientX+e.touches[1].clientX)/2; const dx=(nx-two.x); sepX=clamp(two.base+dx*0.25, 8, 80); applySeparation(); } });
  addEventListener('touchend',()=>two=null);
  function pickStack(t){ const hits=pickAt(t.clientX,t.clientY,[...decks.A.plates,...decks.B.plates]); if(!hits.length) return null; const mesh=hits[0].object; return { which: decks.A.plates.includes(mesh)?'A':'B' } }
  function dist2(t){ const dx=t[0].clientX-t[1].clientX; const dy=t[0].clientY-t[1].clientY; return Math.hypot(dx,dy); }

  // 2) Overlap program: tap center plates
  canvas.addEventListener('pointerdown',ev=>{ const hits=pickAt(ev.clientX,ev.clientY, overlap.plates); if(hits.length){ const idx=overlap.plates.indexOf(hits[0].object); const step=idx % overlap.steps; overlap.seq[step]=overlap.seq[step]?0:1; pulsePlate(overlap.plates[idx]); click(); } }, {capture:true});

  // 3) Control Shelf drag (stacks-as-sliders)
  let ctrlDrag=null; function beginControlShelfDrag(mesh, clientY){ const S = controlShelf.stacks.find(s=>s.plates.includes(mesh)); if(!S) return; ctrlDrag={S, y0:clientY, v0:S.def.getter()}; }
  addEventListener('pointermove',e=>{ if(!ctrlDrag) return; const {S,y0,v0}=ctrlDrag; const dy=y0-e.clientY; const span=(S.def.max-S.def.min); const newVal=v0 + (dy/3); S.def.setter( clamp(newVal,S.def.min,S.def.max) ); refreshControlShelf(); applyAll(); });
  addEventListener('pointerup',()=>ctrlDrag=null);

  // 4) Camera Wall drag
  let camDrag=null; function beginCameraWallDrag(mesh, clientY){ const S=cameraWall.stacks.find(s=>s.plates.includes(mesh)); if(!S) return; camDrag={S, y0:clientY, v0:S.def.getter()}; }
  addEventListener('pointermove',e=>{ if(!camDrag) return; const {S,y0,v0}=camDrag; const dy=y0-e.clientY; const newVal=v0 + (dy/3); S.def.setter( clamp(newVal,S.def.min,S.def.max) ); refreshCameraWall(); });
  addEventListener('pointerup',()=>camDrag=null);

  // 5) Background swipe up/down to show/hide the control shelf
  let bgGesture=null; function beginBackgroundGesture(x,y){ bgGesture={x,y}; }
  addEventListener('pointermove',e=>{ if(!bgGesture) return; const dy=e.clientY-bgGesture.y; if(Math.abs(dy)>40){ controlShelf.shown = dy<0; refreshControlShelf(); bgGesture=null; } });
  addEventListener('pointerup',()=>bgGesture=null);

  // ===== Micro feedback =====
  function pulsePlate(p){ p.material.emissiveIntensity=.98; p.scale.set(1.2,1,1.2); setTimeout(()=>{ p.scale.set(1,1,1); p.material.emissiveIntensity=.22+0.6*energy; },110) }

  // In‑stack tuner overlay (sprite)
  const tunerSprite = mkSprite(''); tunerSprite.position.set(0,20,0); tunerSprite.visible=false; scene.add(tunerSprite);
  function showTuner(which,idx,st){ tunerSprite.visible=true; const g=decks[which].group; tunerSprite.position.set(g.position.x, decks[which].plates[idx].position.y+6, g.position.z); updateSpriteText(tunerSprite, `${st>0?'+':''}${st} st`); }
  function hideTuner(){ tunerSprite.visible=false }

  // ===== Audio Engine =====
  function audioInit(){ if(AC) return; const C=window.AudioContext||window.webkitAudioContext; AC=new C(); master=AC.createGain(); master.gain.value=.22; master.connect(AC.destination); voices.A=buildVoice(decks.A.crate.voice); voices.B=buildVoice(decks.B.crate.voice); voicesReady=true; toast('Audio ready. Stacks are live.'); }
  function buildVoice(kind){ const out=AC.createGain(); out.connect(master); const env=AC.createGain(); env.gain.value=0; const filt=AC.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=1400; filt.Q.value=.7; filt.connect(env).connect(out); function osc(type,det=0){ const o=AC.createOscillator(); o.type=type; o.detune.value=det; o.start(); o.connect(filt); return o; } let parts={env,filt,out}; if(kind==='tape'){ parts.o1=osc('sawtooth',-4); parts.o2=osc('triangle',+4);} else if(kind==='fm'){ parts.o1=osc('square',0); parts.o2=osc('square',+7);} else if(kind==='breaks'){ parts.o1=osc('sawtooth',0);} else if(kind==='supersaw'){ parts.o1=osc('sawtooth',-9); parts.o2=osc('sawtooth',+9);} else if(kind==='trap'){ parts.o1=osc('sine',0);} else { parts.o1=osc('triangle',0); parts.o2=osc('sine',+3);} return parts; }
  function trigger(env,level=.6,dur=.22){ const t=AC.currentTime; env.gain.cancelScheduledValues(t); env.gain.setValueAtTime(env.gain.value,t); env.gain.linearRampToValueAtTime(level,t+0.01); env.gain.exponentialRampToValueAtTime(0.0001,t+dur); }
  function setFilter(parts,cut,q){ parts.filt.frequency.setTargetAtTime(cut,AC.currentTime,.02); parts.filt.Q.setTargetAtTime(q,AC.currentTime,.02); }
  function setFreq(parts,f){ if(parts.o1) parts.o1.frequency.setTargetAtTime(f,AC.currentTime,.02); if(parts.o2) parts.o2.frequency.setTargetAtTime(f*1.001,AC.currentTime,.02); }
  function click(){ if(!AC) return; const o=AC.createOscillator(); const g=AC.createGain(); o.type='triangle'; o.frequency.value=700; o.connect(g).connect(master); const t=AC.currentTime; g.gain.setValueAtTime(.12,t); g.gain.exponentialRampToValueAtTime(0.0001,t+.1); o.start(); o.stop(t+.12) }
  function scaleFreq(scale,root,degree){ const tbl={minorPent:[0,3,5,7,10],majorPent:[0,2,4,7,9],dorian:[0,2,3,5,7,9,10],phrygian:[0,1,5,7,8]}; const arr=tbl[scale]||tbl.minorPent; const semi=arr[degree%arr.length]; return root*Math.pow(2,semi/12) }
  function xfG(x){ return {a:(1-x)/2,b:(1+x)/2} }

  // ===== Sequencer =====
  function startClock(){ let last=performance.now(); function loop(){ if(playing && AC && AC.state==='running'){ const beat=60000/bpm; const stepDur=beat/4; const now=performance.now(); if(now-last>=stepDur){ last+=stepDur; tick(); } } requestAnimationFrame(loop) } loop(); }
  function deckLevel(which){ const base= (which==='A'? (1-(xf+1)/2) : ((xf+1)/2)); const sz=(which==='A'?decks.A.size:decks.B.size); return base*sz; }
  function tick(){ const g=xfG(xf); ['A','B'].forEach(which=>{ const d=decks[which]; d.phase=(d.phase+1)%d.steps; const idx=d.phase; if(d.seq[idx]){ const f=scaleFreq(d.scale,d.root,idx); const tuned=f*Math.pow(2,(d.tune[idx]||0)/12); if(AC&&voicesReady){ const v=(which==='A')?voices.A:voices.B; const weight=deckLevel(which); setFreq(v,tuned); setFilter(v, 900+2400*energy, .7+5*resonance); trigger(v.env, .28 + .55*weight, .16 + .12*resonance); }
        const plate=d.plates[idx % Math.max(1,d.layers)]; if(plate){ plate.scale.set(decks[which].size*1.18,1,decks[which].size*1.18); setTimeout(()=>{ plate.scale.set(decks[which].size,1,decks[which].size); }, 100); }
    } });
    // Overlap pad when both decks hit or overlap sequence triggers
    const sepGain = 1 - Math.min(1, (sepX-8)/80); if(AC&&voicesReady){ const bothHit = (decks.A.seq[decks.A.phase] && decks.B.seq[decks.B.phase]); if(bothHit || overlap.seq[overlap.phase]){ trigger(voices.A.env, .12*sepGain, .35 + .3*resonance); } }
    overlap.phase=(overlap.phase+1)%overlap.steps;
  }

  // ===== Helpers =====
  function setXF(x){ xf=clamp(x,-1,1); const g=xfG(xf); decks.A.layers = clamp(Math.round(10+g.a*18),6,MAX_PLATES); decks.B.layers = clamp(Math.round(10+g.b*18),6,MAX_PLATES); refreshDeckVisual('A'); refreshDeckVisual('B'); if(navigator.vibrate) navigator.vibrate(3); }
  function setTune(which,idx,st){ decks[which].tune[idx%32]=st }
  function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
  const toastEl=document.getElementById('toast'); function toast(m){ toastEl.textContent=m; toastEl.style.display='block'; clearTimeout(toast._id); toast._id=setTimeout(()=>toastEl.style.display='none',1100) }

  // ===== Camera control (orbit + preset cycle) =====
  function updateCam(){ if(orbit){ tOrbit+=0.004*(60/bpm); const R=dist; camera.position.x=Math.sin(tOrbit)*R; camera.position.z=Math.cos(tOrbit)*R; camera.position.y=56; camera.lookAt(0,12,0); } }
  // Double-tap empty toggles camera view, triple-tap toggles orbit
  let lastTap=0, tapCount=0; canvas.addEventListener('pointerdown',e=>{ const hits=pickAt(e.clientX,e.clientY,[...decks.A.plates,...decks.B.plates,...overlap.plates]); if(hits.length) return; const now=performance.now(); tapCount = (now-lastTap<280) ? tapCount+1 : 1; lastTap=now; clearTimeout(canvas._tapTimer); canvas._tapTimer=setTimeout(()=>{ if(tapCount===2){ viewIdx=(viewIdx+1)%VIEWS.length; applyView(); } else if(tapCount>=3){ orbit=!orbit; showViewLabel(orbit?'ORBIT ON':'ORBIT OFF'); } tapCount=0; }, 300); }, {capture:true});

  // ===== First interaction → enable audio & start
  let primed=false; canvas.addEventListener('pointerdown', async ()=>{ if(!primed){ audioInit(); if(AC.state!=='running') await AC.resume(); playing=true; primed=true; toast('Playing — pull up center to reveal control stacks.'); } }, {once:true});

  // ===== Render =====
  function animate(){ requestAnimationFrame(animate); updateCam(); renderer.render(scene,camera) }

  // ===== Build and refresh
  applySeparation(); refreshControlShelf(); refreshCameraWall(); applyView();

  // ===== Tests =====
  ;(function tests(){ const results=[]; results.push(['T1 THREE loaded', !!window.THREE]); results.push(['T2 decks exist', !!(decks.A&&decks.B)]); results.push(['T3 control shelf exists', !!controlShelf.group]); results.push(['T4 camera wall exists', !!cameraWall.group]); console.table(results.map(([n,p])=>({test:n,pass:p}))); })();

  startClock(); animate();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VOL‑MEDIA DECKS v9.5 — Ring/Grid + Drum/Tube Layouts, EquiGrid, Auto‑Fit (Balanced Braces Fix)</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;touch-action:none}
  html,body{height:100%}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#000;color:#fff;overflow:hidden}
  #canvas{width:100vw;height:100vh;display:block}
  #toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.85);border:1px solid rgba(255,255,255,.2);padding:6px 10px;border-radius:10px;font-size:12px;color:#fff;z-index:6;display:none}
  /* HUD: fixed on screen, never moves with camera */
  #hud{position:fixed; inset:0; pointer-events:none; z-index:5}
  #viewHUD{position:absolute; left:50%; top:18px; transform:translateX(-50%); font-weight:800; font-size:14px; letter-spacing:.4px; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.18); padding:6px 10px; border-radius:999px}
  #viewBackups{position:absolute; right:10px; top:10px; display:flex; gap:6px; pointer-events:auto; flex-direction:column; align-items:flex-end}
  .row{display:flex; gap:6px}
  .vDot, .qSquare{width:16px; height:16px; border-radius:3px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.22); cursor:pointer}
  .vDot.active{background:rgba(89,224,255,.7)}
  /* Quick toolbar beneath view dots */
  #quickSwitch{margin-top:6px; display:flex; gap:6px}
  .qSquare{display:flex; align-items:center; justify-content:center; font-size:9px; font-weight:700; color:#fff; background:rgba(0,0,0,.5)}
  .qSquare.on{background:rgba(0,0,0,.8)}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="hud">
  <div id="viewHUD">FRONT</div>
  <div id="viewBackups"><div class="row" id="viewDotsRow"></div><div id="quickSwitch"></div></div>
</div>
<div id="toast"></div>
<script>
(async function(){
  // ---- Load THREE safely if absent
  if(!window.THREE){
    const CDNs=['https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js','https://unpkg.com/three@0.152.2/build/three.min.js','https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'];
    for(const src of CDNs){
      try{
        await new Promise((res,rej)=>{const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s)});
        if(window.THREE) break;
      }catch(e){}
    }
  }

  // ===== Scene =====
  const canvas=document.getElementById('canvas');
  const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
  const camera=new THREE.PerspectiveCamera(54, innerWidth/innerHeight, .1, 3000); camera.position.set(80,56,96); camera.lookAt(0,12,0);
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true}); renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight)});

  // ===== HUD handles view label & backup view buttons =====
  const viewHUD = document.getElementById('viewHUD');
  const viewDotsRow = document.getElementById('viewDotsRow');
  const quickSwitch = document.getElementById('quickSwitch');
  function showViewLabel(txt){ viewHUD.textContent = txt; }

  // ===== Camera Presets (DECLARED EARLY & USED LATER) =====
  const VIEWS=[
    {name:'FRONT',pos:[0,34,110]},
    {name:'ISO L',pos:[-85,42,70]},
    {name:'ISO R',pos:[85,42,70]},
    {name:'SIDE',pos:[0,36,-110]},
    {name:'TOP',pos:[0,130,0.01]}
  ];
  let viewIdx=1, orbit=false, orbitSpeed=18, tOrbit=0, dist=120; // camera globals
  function applyView(){ const v=VIEWS[viewIdx%VIEWS.length]; camera.position.set(...v.pos); camera.lookAt(0,12,0); showViewLabel(v.name); syncViewDots(); }

  // Build backup view squares *after* VIEWS & viewIdx exist
  function buildViewBackups(){
    viewDotsRow.innerHTML='';
    VIEWS.forEach((v,i)=>{ const d=document.createElement('div'); d.className='vDot'; d.title=v.name; d.addEventListener('click',()=>{ viewIdx=i; applyView(); }); viewDotsRow.appendChild(d); });
    // Build quick switch squares beneath
    quickSwitch.innerHTML='';
    const mkBtn=(label,cb)=>{ const b=document.createElement('div'); b.className='qSquare'; b.textContent=label; b.addEventListener('click',cb); return b; };
    quickSwitch.appendChild(mkBtn('R',()=>{ hub.layoutMode='ring'; refreshHubLayout(); toast('Layout: RING'); }));
    quickSwitch.appendChild(mkBtn('G',()=>{ hub.layoutMode='grid'; refreshHubLayout(); toast('Layout: GRID'); }));
    quickSwitch.appendChild(mkBtn('DRM',()=>{ hub.layoutMode='drum'; refreshHubLayout(); toast('Layout: DRUM'); }));
    quickSwitch.appendChild(mkBtn('TUBE',()=>{ hub.layoutMode='tube'; refreshHubLayout(); toast('Layout: TUBE'); }));
    quickSwitch.appendChild(mkBtn('EQG',()=>{ hub.layoutMode='equigrid'; refreshHubLayout(); toast('Layout: EQUIGRID'); }));
    quickSwitch.appendChild(mkBtn('2×5',()=>{ hub.layoutMode='grid'; hub.gridRows=2; hub.gridCols=5; refreshHubLayout(); toast('Grid: 2×5'); }));
    quickSwitch.appendChild(mkBtn('3×4',()=>{ hub.layoutMode='grid'; hub.gridRows=3; hub.gridCols=4; refreshHubLayout(); toast('Grid: 3×4'); }));
    quickSwitch.appendChild(mkBtn('4×3',()=>{ hub.layoutMode='grid'; hub.gridRows=4; hub.gridCols=3; refreshHubLayout(); toast('Grid: 4×3'); }));
    quickSwitch.appendChild(mkBtn('REG',()=>{ hub.regular = !hub.regular; refreshHubLayout(); makeRegularPatterns(hub.regular); toast(hub.regular?'Regular: ON':'Regular: OFF'); }));
    quickSwitch.appendChild(mkBtn('SPC',()=>{ cycleSpacingPreset(); }));
    quickSwitch.appendChild(mkBtn('VIS',()=>{ ensureAllVisible(); toast('Auto-fit view'); }));
    syncViewDots();
  }
  function syncViewDots(){ [...viewDotsRow.children].forEach((el,i)=> el.classList.toggle('active', i===viewIdx)); }

  // ===== State =====
  const CRATES=[
    {id:'70s', name:'1970s', col:0xffa44d, voice:'tape'},
    {id:'80s', name:'1980s', col:0x59e0ff, voice:'fm'},
    {id:'90s', name:'1990s', col:0x7da1ff, voice:'breaks'},
    {id:'00s', name:'2000s', col:0xffffff, voice:'supersaw'},
    {id:'10s', name:'2010s', col:0x00d4aa, voice:'trap'},
    {id:'20s', name:'2020s', col:0xc47dff, voice:'neural'}
  ];

  const decks={
    A:{color:0x00ff88, crate:CRATES[1], steps:16, root:110, scale:'minorPent', spacing:1.12, layers:16, size:1.0, seq:Array(32).fill(0), tune:Array(32).fill(0), phase:0, group:null, plates:[], subs:{}},
    B:{color:0xff4488, crate:CRATES[3], steps:16, root:220, scale:'majorPent', spacing:1.12, layers:16, size:1.0, seq:Array(32).fill(0), tune:Array(32).fill(0), phase:0, group:null, plates:[], subs:{}}
  };

  // Global engine vars
  let bpm=112, energy=.45, resonance=.5, playing=false, xf=0; // xf -1..+1 (A..B)
  let AC, master, convolver, wet, dry, voices={A:null,B:null}; let voicesReady=false;

  const MAX_PLATES=28, SIZE=12;

  // ===== Base builders =====
  function mkSprite(text){ const cvs=document.createElement('canvas'); const s=256; cvs.width=cvs.height=s; const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,s,s); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s); ctx.fillStyle='white'; ctx.font='bold 48px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=12; ctx.fillText(text,s/2,s/2); const tex=new THREE.CanvasTexture(cvs); const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false}); const spr=new THREE.Sprite(mat); spr.scale.set(8,8,1); return spr; }
  function updateSpriteText(sprite,txt){ const t = sprite.material.map.image; const ctx=t.getContext('2d'); const s=t.width; ctx.clearRect(0,0,s,s); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s); ctx.fillStyle='#ffffff'; ctx.font='bold 48px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.7)'; ctx.shadowBlur=14; ctx.fillText(txt,s/2,s/2); sprite.material.map.needsUpdate=true; }
  function mkPlate(color,op){ const g=new THREE.PlaneGeometry(SIZE,SIZE); const m=new THREE.MeshStandardMaterial({color,transparent:true,opacity:op,side:THREE.DoubleSide,depthWrite:false,roughness:.55,metalness:.08}); const mesh=new THREE.Mesh(g,m); mesh.rotation.x=-Math.PI/2; m.emissive=new THREE.Color(color); m.emissiveIntensity=.22; return mesh; }

  // ===== Primary Decks =====
  let sepBase=30, sepMin=8, sepX=sepBase, couple=0.0; // couple 0..1 controls attractive overlap when crossfader near center
  function updateCoupledSeparation(){ const t=Math.abs(xf); const blend = couple*(1 - t); sepX = lerp(sepBase, sepMin, blend); applySeparation(); updateAudioLinks(); }

  function buildDeck(which, x){ const d=decks[which]; if(d.group){ scene.remove(d.group); d.plates.forEach(p=>{p.geometry.dispose?.(); p.material.dispose?.();}); d.plates.length=0; }
    const g=new THREE.Group(); g.position.set(x,0,0);
    for(let i=0;i<MAX_PLATES;i++){ const base=.9-(i/MAX_PLATES)*.55; const p=mkPlate(d.color,Math.max(.22,base*.5)); p.position.y=i*d.spacing; g.add(p); d.plates.push(p); }
    const tag=mkSprite(which); tag.position.set(0,2,0); g.add(tag); d.subs.tag=tag;
    scene.add(g); d.group=g; refreshDeckVisual(which,true);
  }
  buildDeck('A',-sepX); buildDeck('B',sepX);

  function refreshDeckVisual(which){ const d=decks[which]; const activeColor=new THREE.Color(d.color).lerp(new THREE.Color(0xffffff), 0.3*resonance);
    const baseScale=d.size*(1+0.06*energy); const EI=0.18+0.6*energy; const OP=0.3+0.6*energy; d.plates.forEach((p,i)=>{
      const vis=i<d.layers; p.visible=vis; if(!vis) return; p.position.y=i*d.spacing; p.scale.set(baseScale,1,baseScale);
      p.material.color.copy(activeColor); p.material.emissive.copy(new THREE.Color(d.color));
      p.material.emissiveIntensity = EI*(0.95 - (i/Math.max(1,d.layers))*0.5);
      p.material.opacity = OP*(0.95 - (i/Math.max(1,d.layers))*0.4);
    });
  }
  function applySeparation(){ decks.A.group.position.x=-sepX; decks.B.group.position.x=sepX; hub.group.position.x=0; overlap.group.position.x=0; }
  function applyAll(){ refreshDeckVisual('A'); refreshDeckVisual('B'); refreshOverlapVisual(); refreshHub(); applySeparation(); updateAudioLinks(); }

  // ===== Overlap musical stack =====
  const overlap={color:0xffaa00, steps:16, spacing:1.12, layers:12, seq:Array(32).fill(0), tune:Array(32).fill(0), phase:0, group:null, plates:[]};
  (function buildOverlap(){ const g=new THREE.Group(); g.position.set(0,0,0); overlap.group=g; for(let i=0;i<MAX_PLATES;i++){ const p=mkPlate(overlap.color, .16); p.position.y=i*overlap.spacing; g.add(p); overlap.plates.push(p);} scene.add(g); refreshOverlapVisual(); })();
  function refreshOverlapVisual(){ const EI=.12+.5*energy; const OP=.18+.5*energy; for(let i=0;i<overlap.plates.length;i++){ const p=overlap.plates[i]; const vis=i<overlap.layers; p.visible=vis; if(!vis) continue; p.position.y=i*overlap.spacing; p.material.emissiveIntensity = EI*(0.95 - (i/Math.max(1,overlap.layers))*0.5); p.material.opacity = OP*(0.95 - (i/Math.max(1,overlap.layers))*0.4); } }

  // ===== HUB — planar placement: all stacks on same surface (y = plane), spread around center
  const hub={group:new THREE.Group(), shown:true, stacks:[], planeY:2, angle:0, inertia:0,
    layoutMode:'ring', gridRows:2, gridCols:5,
    design:{a:50,b:50,c:50},
    ring:{outerR:28, innerR:16, split:5},
    tube:{radius:24, height:10},
    equigrid:{maxPerRow:5, marginX:10, marginZ:8},
    regular:false
  }; scene.add(hub.group);
  function buildHub(){
    const defs=[
      // Core performance controls (must remain 10 to satisfy existing tests)
      {name:'BPM', color:0x59e0ff, getter:()=>bpm, setter:v=>{ bpm=clamp(Math.round(v),60,180); }, min:60, max:180},
      {name:'ENERGY', color:0x00ff88, getter:()=>energy*100, setter:v=>{ energy=clamp(v/100,0,1) }, min:0, max:100},
      {name:'RES', color:0xffa44d, getter:()=>resonance*100, setter:v=>{ resonance=clamp(v/100,0,1) }, min:0, max:100},
      {name:'MIX', color:0xff4488, getter:()=>((xf+1)/2)*100, setter:v=>{ setXF((clamp(v,0,100)/100)*2-1) }, min:0, max:100},
      {name:'SIZE', color:0xffffff, getter:()=>Math.round(decks.A.size*100), setter:v=>{ const s=clamp(v,70,160)/100; decks.A.size=decks.B.size=s; }, min:70, max:160},
      {name:'SEP', color:0x7da1ff, getter:()=>sepBase, setter:v=>{ sepBase=clamp(v,8,120); updateCoupledSeparation(); }, min:8, max:120},
      {name:'LAYERS', color:0xc47dff, getter:()=>Math.round((decks.A.layers+decks.B.layers)/2), setter:v=>{ const L=clamp(Math.round(v),6,MAX_PLATES); decks.A.layers=L; decks.B.layers=L; }, min:6, max:MAX_PLATES},
      {name:'COUPLE', color:0x00d4aa, getter:()=>Math.round(couple*100), setter:v=>{ couple=clamp(v,0,100)/100; updateCoupledSeparation(); }, min:0, max:100},
      {name:'VIEW', color:0x9ad7ff, getter:()=>viewIdx*20, setter:v=>{ viewIdx=Math.round(clamp(v/20,0,VIEWS.length-1)); applyView(); }, min:0, max:(VIEWS.length-1)*20},
      {name:'ORBIT', color:0xff88cc, getter:()=>orbit?orbitSpeed:0, setter:v=>{ orbit = v>1; orbitSpeed = clamp(v,0,40); }, min:0, max:40}
    ];
    // Build nodes
    defs.forEach((d,i)=>{
      const g=new THREE.Group();
      const plates=[]; const P=16; for(let j=0;j<P;j++){ const p=mkPlate(d.color,0.22); p.position.y=j*1.15; g.add(p); plates.push(p); }
      const tag=mkSprite(d.name); tag.position.set(0,P*1.15+2,0); g.add(tag);
      hub.group.add(g); hub.stacks.push({def:d, group:g, plates, tag});
    });
    refreshHubLayout();
  }
  buildHub();

  function refreshHubLayout(){
    const total=hub.stacks.length;
    if(hub.layoutMode==='grid'){
      const rows=hub.gridRows, cols=hub.gridCols; const gapPreset = getGap(); const gapX=gapPreset.x, gapZ=gapPreset.z; const startX=-(cols-1)*gapX/2; const startZ=-(rows-1)*gapZ/2;
      hub.stacks.forEach((S,i)=>{ const r=Math.floor(i/cols)%rows; const c=i%cols; const x=startX + c*gapX; const z=startZ + r*gapZ; S.group.position.set(x, hub.planeY, z); if(hub.regular){ S.group.rotation.set(0,0,0); S.group.scale.set(1,1,1); } });
    } else if(hub.layoutMode==='equigrid'){
      // auto-compute a nearly square grid (<= maxPerRow)
      const maxPerRow=hub.equigrid.maxPerRow; const cols=Math.min(maxPerRow, Math.ceil(Math.sqrt(total))); const rows=Math.ceil(total/cols);
      const gap=getGap(); const startX=-(cols-1)*gap.x/2; const startZ=-(rows-1)*gap.z/2;
      hub.stacks.forEach((S,i)=>{ const r=Math.floor(i/cols); const c=i%cols; const x=startX+c*gap.x; const z=startZ+r*gap.z; S.group.position.set(x, hub.planeY, z); if(hub.regular){ S.group.rotation.set(0,0,0); S.group.scale.set(1,1,1);} });
    } else if(hub.layoutMode==='drum'){
      // two concentric rings, distribute evenly
      const outerR=hub.ring.outerR, innerR=hub.ring.innerR; const split=Math.min(hub.ring.split, total);
      hub.stacks.forEach((S,i)=>{
        const ring = i<split?1:2; const idx = ring===1? i : (i-split);
        const cnt = ring===1? split : (total-split);
        const ang = (idx/cnt)*Math.PI*2 + hub.angle;
        const rad = ring===1? outerR : innerR;
        S.group.position.set(Math.cos(ang)*rad, hub.planeY, Math.sin(ang)*rad);
      });
    } else if(hub.layoutMode==='tube'){
      // circular ring with slight vertical undulation to reduce overlap, still mostly planar
      const R=hub.tube.radius; const H=hub.tube.height;
      hub.stacks.forEach((S,i)=>{ const ang = (i/total)*Math.PI*2 + hub.angle; const y = hub.planeY + Math.sin(ang*2)*H*0.15; S.group.position.set(Math.cos(ang)*R, y, Math.sin(ang)*R); });
    } else {
      // default ring (two-ring arc band)
      const R=hub.ring.outerR; const innerR=hub.ring.innerR; const split=Math.min(hub.ring.split, total);
      hub.stacks.forEach((S,i)=>{
        const ring = i<split?1:2; const idx = ring===1? i : (i-split);
        const count = ring===1? split : Math.max(1,total-split);
        const ang = (idx/count)*Math.PI*1.4 + (ring===1? -Math.PI*0.7 : -Math.PI*0.1) + hub.angle;
        const rad = ring===1? R : innerR;
        S.group.position.set(Math.cos(ang)*rad, hub.planeY, Math.sin(ang)*rad);
      });
    }
    applyDesignAxes();
    autoFlattenStackHeights();
  }

  function refreshHub(){
    hub.stacks.forEach(S=>{ const v=clamp((S.def.getter()-S.def.min)/(S.def.max-S.def.min),0,1); const nOn=Math.round(v*S.plates.length); S.plates.forEach((p,idx)=>{ p.visible=true; const on=idx<nOn; p.material.opacity = on? 0.72 : 0.12; p.material.emissiveIntensity = on? 0.9 : 0.15; p.scale.set(1+(on?0.08:0),1,1+(on?0.08:0)); }); });
    hub.group.visible = !!hub.shown;
    refreshHubLayout();
  }

  function applyDesignAxes(){
    const a=hub.design?.a/100||0.5, b=hub.design?.b/100||0.5, c=hub.design?.c/100||0.5;
    const tiltX=(a-0.5)*0.6; const tiltZ=(b-0.5)*0.6; const scaleBase=0.9 + 0.4*c; // slightly higher base to keep stacks readable
    hub.stacks.forEach(S=>{
      if((hub.layoutMode==='grid' || hub.layoutMode==='equigrid') && hub.regular){ // perfect orthogonal in regular grids
        S.group.rotation.set(0,0,0); S.group.scale.set(1,1,1);
      } else {
        S.group.rotation.set(tiltX, 0, tiltZ);
        const s=scaleBase; S.group.scale.set(s,s,s);
      }
      const P=S.plates.length; for(let j=0;j<P;j++){ const p=S.plates[j]; p.position.y = j * (0.9 + 0.5*(1-c)); }
    });
  }
  // ===== Visibility/Height helpers =====
  function autoFlattenStackHeights(){
    // reduce visual height by lowering layers if necessary so all stay readable
    const maxVisualLayers = 14; // cap
    hub.stacks.forEach(S=>{
      const plates=S.plates; for(let j=0;j<plates.length;j++){ plates[j].visible = j<Math.min(plates.length, maxVisualLayers); }
    });
  }
  function ensureAllVisible(){
    // Fit camera distance based on hub stack positions
    const pts = hub.stacks.map(S=>S.group.position);
    if(!pts.length) return;
    let minX=Infinity,maxX=-Infinity,minZ=Infinity,maxZ=-Infinity; pts.forEach(p=>{ if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x; if(p.z<minZ) minZ=p.z; if(p.z>maxZ) maxZ=p.z; });
    const w=maxX-minX, d=maxZ-minZ; const diag=Math.hypot(w,d);
    dist = Math.max(100, diag*1.1 + 40); // move cam on orbit ring
    applyView();
  }

  // ===== Regular pattern helpers =====
  const spacingPresets=[{x:10,z:8},{x:12,z:10},{x:14,z:12}]; let spacingIdx=0;
  function getGap(){ return spacingPresets[spacingIdx % spacingPresets.length]; }
  function cycleSpacingPreset(){ spacingIdx=(spacingIdx+1)%spacingPresets.length; refreshHubLayout(); toast('Spacing: '+getGap().x+'×'+getGap().z); }
  function makeRegularPatterns(on){ if(!on) return; // even-odd steps for both decks; overlap every 4
    ['A','B'].forEach((w,wi)=>{ const d=decks[w]; for(let i=0;i<d.steps;i++){ d.seq[i] = (i % (wi?2:2)===0)?1:0; } });
    for(let i=0;i<overlap.steps;i++){ overlap.seq[i] = (i%4===0)?1:0; }
  }

  // ===== Gestures =====
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pickAt(clientX,clientY,objects){ v2.x=(clientX/innerWidth)*2-1; v2.y=-(clientY/innerHeight)*2+1; ray.setFromCamera(v2,camera); return ray.intersectObjects(objects); }

  // Deck & Hub gestures
  let dragging=false, activeDeck=null, mode=null, start={x:0,y:0}, hold=false, tuneIdx=null;
  let hubDrag=null; // {S,y0,v0}
  let bgSwipe=null; // background swipe state

  canvas.addEventListener('pointerdown',ev=>{
    const deckHits=pickAt(ev.clientX,ev.clientY,[...decks.A.plates,...decks.B.plates]);
    if(deckHits.length){
      const mesh=deckHits[0].object; const which = decks.A.plates.includes(mesh)?'A':'B'; activeDeck=which; dragging=true; start.x=ev.clientX; start.y=ev.clientY; hold=true; tuneIdx=(which==='A'?decks.A.plates.indexOf(mesh):decks.B.plates.indexOf(mesh));
      setTimeout(()=>{ if(hold){ mode='tune'; showTuner(which,tuneIdx,0); if(navigator.vibrate) navigator.vibrate(7); } },280);
      return;
    }
    // Try HUB plates
    const hubMeshes = hub.group.children.flatMap(g=>g.children).filter(o=>o.isMesh);
    const hubHits=pickAt(ev.clientX,ev.clientY, hubMeshes);
    if(hubHits.length){
      const mesh=hubHits[0].object; const S = hub.stacks.find(s=>s.plates.includes(mesh));
      if(S){ hubDrag={S, y0:ev.clientY, v0:S.def.getter()}; if(navigator.vibrate) navigator.vibrate(4); return; }
    }
    // Background swipe (horizontal: rotate hub, vertical: show/hide hub)
    bgSwipe={x0:ev.clientX, y0:ev.clientY, x:ev.clientX, y:ev.clientY, active:true};
  });

  canvas.addEventListener('pointermove',ev=>{
    // Hub drag
    if(hubDrag){ const {S,y0,v0}=hubDrag; const dy=y0-ev.clientY; const newVal=v0 + (dy/3); S.def.setter( clamp(newVal,S.def.min,S.def.max) ); refreshHub(); applyAll(); return; }

    // Deck drag
    if(dragging&&activeDeck){ const dx=ev.clientX-start.x; const dy=ev.clientY-start.y; const d=decks[activeDeck];
      if(mode==='tune'){
        const st=clamp(Math.round(-dy/12),-12,12); setTune(activeDeck,tuneIdx,st); showTuner(activeDeck,tuneIdx,st); previewTone(activeDeck,tuneIdx,st);
      } else {
        hold=false;
        if(Math.abs(dy)>Math.abs(dx)){
          d.spacing = clamp(d.spacing + (-dy)*0.002, 0.6, 2.0); start.y=ev.clientY; refreshDeckVisual(activeDeck); updateAudioLinks();
        } else {
          setXF(xf + dx*0.004); start.x=ev.clientX; updateAudioLinks();
        }
      }
      return;
    }

    // Background swipe/rotate
    if(bgSwipe&&bgSwipe.active){
      bgSwipe.x=ev.clientX; bgSwipe.y=ev.clientY; const dx=bgSwipe.x-bgSwipe.x0; const dy=bgSwipe.y-bgSwipe.y0;
      if(Math.abs(dx)>Math.abs(dy)){
        hub.angle += dx*0.0025; hub.inertia = dx*0.001; refreshHubLayout(); bgSwipe.x0=bgSwipe.x;
      } else if(Math.abs(dy)>40){
        hub.shown = dy<0; refreshHub(); bgSwipe.active=false;
      }
    }
  });

  addEventListener('pointerup',ev=>{
    if(dragging&&activeDeck){
      if(mode==='tune'){
        hideTuner();
      } else {
        const d=decks[activeDeck]; const step=tuneIdx % d.steps; d.seq[step]=d.seq[step]?0:1; pulsePlate((activeDeck==='A'?decks.A.plates:decks.B.plates)[tuneIdx]); click();
      }
    }
    dragging=false; activeDeck=null; hold=false; mode=null; tuneIdx=null;
    hubDrag=null; bgSwipe=null;
  });

  // Overlap program: tap center plates
  canvas.addEventListener('pointerdown',ev=>{
    const hits=pickAt(ev.clientX,ev.clientY, overlap.plates);
    if(hits.length){ const idx=overlap.plates.indexOf(hits[0].object); const step=idx % overlap.steps; overlap.seq[step]=overlap.seq[step]?0:1; pulsePlate(overlap.plates[idx]); click(); }
  }, {capture:true});

  // ===== Micro feedback =====
  function pulsePlate(p){ p.material.emissiveIntensity=.98; p.scale.set(1.2,1,1.2); setTimeout(()=>{ p.scale.set(1,1,1); p.material.emissiveIntensity=.22+0.6*energy; },110); }

  // In‑stack tuner overlay (sprite)
  const tunerSprite = mkSprite(''); tunerSprite.position.set(0,20,0); tunerSprite.visible=false; scene.add(tunerSprite);
  function showTuner(which,idx,st){ tunerSprite.visible=true; const g=decks[which].group; tunerSprite.position.set(g.position.x, decks[which].plates[idx].position.y+6, g.position.z); updateSpriteText(tunerSprite, `${st>0?'+':''}${st} st`); }
  function hideTuner(){ tunerSprite.visible=false; }

  // ===== Audio Engine =====
  function makeIR(sec=1.6, decay=3){ const rate = AC.sampleRate, len = rate*sec; const ir = AC.createBuffer(2, len, rate); for(let ch=0; ch<2; ch++){ const d = ir.getChannelData(ch); for(let i=0;i<len;i++){ d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, decay); } } return ir; }
  function audioInit(){ if(AC) return; const C=window.AudioContext||window.webkitAudioContext; AC=new C(); master=AC.createGain(); master.gain.value=.22; master.connect(AC.destination);
    convolver=AC.createConvolver(); convolver.buffer=makeIR(); wet=AC.createGain(); dry=AC.createGain(); wet.gain.value=.25; dry.gain.value=.75; const bus=AC.createGain(); bus.gain.value=1; bus.connect(dry).connect(master); wet.connect(convolver).connect(master);
    voices.A=buildVoice(decks.A.crate.voice); voices.B=buildVoice(decks.B.crate.voice); voicesReady=true; updateAudioLinks(); toast('Audio ready. Stacks are live.'); }
  function buildVoice(kind){ const out=AC.createGain(); out.gain.value=1; const env=AC.createGain(); env.gain.value=0; const filt=AC.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=1400; filt.Q.value=.7; const pan=AC.createStereoPanner(); pan.pan.value=0; const detLFO=AC.createOscillator(); const detAmt=AC.createGain(); detAmt.gain.value=0; detLFO.type='sine'; detLFO.frequency.value=.25; detLFO.start(); detLFO.connect(detAmt);
    function osc(type,det=0){ const o=AC.createOscillator(); o.type=type; o.detune.value=det; o.start(); detAmt.connect(o.detune); o.connect(filt); return o; }
    let parts={env,filt,out,pan,detAmt}; filt.connect(env).connect(out); out.connect(dry); out.connect(wet); out.connect(pan).connect(master);
    if(kind==='tape'){ osc('sawtooth',-4); osc('triangle',+4);} else if(kind==='fm'){ osc('square',0); osc('square',+7);} else if(kind==='breaks'){ osc('sawtooth',0);} else if(kind==='supersaw'){ osc('sawtooth',-9); osc('sawtooth',+9);} else if(kind==='trap'){ osc('sine',0);} else { osc('triangle',0); osc('sine',+3);} return parts; }
  function trigger(env,level=.6,dur=.22){ const t=AC.currentTime; env.gain.cancelScheduledValues(t); env.gain.setValueAtTime(env.gain.value,t); env.gain.linearRampToValueAtTime(level,t+0.01); env.gain.exponentialRampToValueAtTime(0.0001,t+dur); }
  function setFilter(parts,cut,q){ parts.filt.frequency.setTargetAtTime(cut,AC.currentTime,.02); parts.filt.Q.setTargetAtTime(q,AC.currentTime,.02); }
  function setFreq(parts,f){ /* hooked via detune LFO; base is filter resonance */ }
  function click(){ if(!AC) return; const o=AC.createOscillator(); const g=AC.createGain(); o.type='triangle'; o.frequency.value=700; o.connect(g).connect(master); const t=AC.currentTime; g.gain.setValueAtTime(.12,t); g.gain.exponentialRampToValueAtTime(0.0001,t+.1); o.start(); o.stop(t+.12); }
  function previewTone(which,idx,st){ if(!AC||!voicesReady) return; const d=decks[which]; const f=scaleFreq(d.scale,d.root, idx % d.steps); const tuned=f*Math.pow(2,st/12); const v=(which==='A')?voices.A:voices.B; v.filt.frequency.setTargetAtTime(400+tuned,AC.currentTime,.02); trigger(v.env,.12,.12); }
  function scaleFreq(scale,root,degree){ const tbl={minorPent:[0,3,5,7,10],majorPent:[0,2,4,7,9],dorian:[0,2,3,5,7,9,10],phrygian:[0,1,5,7,8]}; const arr=tbl[scale]||tbl.minorPent; const semi=arr[degree%arr.length]; return root*Math.pow(2,semi/12); }
  function xfG(x){ return {a:(1-x)/2,b:(1+x)/2}; }
  function lerp(a,b,t){ return a*(1-t)+b*t; }

  // Map controls tighter to sonics + visuals
  function updateAudioLinks(){ if(!AC||!voicesReady) return; const g=xfG(xf);
    // Energy → master loudness & plate emissive gain
    master.gain.setTargetAtTime(0.15 + 0.4*energy, AC.currentTime, .05);
    // Resonance → filter Q
    [voices.A, voices.B].forEach(v=> setFilter(v, 600 + 2600*energy, 0.8 + resonance*8));
    // Crossfader + separation → panning & wetness
    voices.A.pan.pan.setTargetAtTime(-Math.min(1, sepBase/120)*(1-g.a), AC.currentTime, .02);
    voices.B.pan.pan.setTargetAtTime(+Math.min(1, sepBase/120)*(1-g.b), AC.currentTime, .02);
    wet.gain.setTargetAtTime(0.15 + 0.5*(decks.A.layers+decks.B.layers)/(2*MAX_PLATES), AC.currentTime, .08);
    dry.gain.setTargetAtTime(1 - wet.gain.value, AC.currentTime, .1);
    // Size → detune jitter amount
    const detAmt = (decks.A.size+decks.B.size)/2; [voices.A,voices.B].forEach(v=> v.detAmt.gain.setTargetAtTime(3 + detAmt*6 + couple*10, AC.currentTime, .1));
  }

  // ===== Sequencer =====
  function startClock(){ let last=performance.now(); function loop(){ if(playing && AC && AC.state==='running'){ const beat=60000/bpm; const stepDur=beat/4; const now=performance.now(); if(now-last>=stepDur){ last+=stepDur; tick(); } } requestAnimationFrame(loop); } loop(); }
  function deckLevel(which){ const base= (which==='A'? (1-(xf+1)/2) : ((xf+1)/2)); const sz=(which==='A'?decks.A.size:decks.B.size); return base*sz; }
  function tick(){ ['A','B'].forEach(which=>{ const d=decks[which]; d.phase=(d.phase+1)%d.steps; const idx=d.phase; if(d.seq[idx]){ const f=scaleFreq(d.scale,d.root,idx); const tuned=f*Math.pow(2,(d.tune[idx]||0)/12); if(AC&&voicesReady){ const v=(which==='A')?voices.A:voices.B; const weight=deckLevel(which); v.filt.frequency.setTargetAtTime(400+tuned*(0.5+energy),AC.currentTime,.02); setFilter(v, 800+2800*energy, .9+6*resonance); trigger(v.env, .22 + .6*weight, .16 + .12*resonance); }
        const plate=d.plates[idx % Math.max(1,d.layers)]; if(plate){ plate.scale.set(decks[which].size*1.18,1,decks[which].size*1.18); setTimeout(()=>{ plate.scale.set(decks[which].size,1,decks[which].size); }, 100); }
    } });
    const sepGain = 1 - Math.min(1, (sepX-sepMin)/(sepBase-sepMin+0.0001)); if(AC&&voicesReady){ const bothHit = (decks.A.seq[decks.A.phase] && decks.B.seq[decks.B.phase]); if(bothHit || overlap.seq[overlap.phase]){ trigger(voices.A.env, .12*sepGain, .35 + .3*resonance); } }
    overlap.phase=(overlap.phase+1)%overlap.steps;
  }

  // ===== Helpers =====
  function setXF(x){ xf=clamp(x,-1,1); const g=xfG(xf); decks.A.layers = clamp(Math.round(10+g.a*18),6,MAX_PLATES); decks.B.layers = clamp(Math.round(10+g.b*18),6,MAX_PLATES); refreshDeckVisual('A'); refreshDeckVisual('B'); updateCoupledSeparation(); if(navigator.vibrate) navigator.vibrate(3); }
  function setTune(which,idx,st){ decks[which].tune[idx%32]=st; }
  function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
  const toastEl=document.getElementById('toast'); function toast(m){ toastEl.textContent=m; toastEl.style.display='block'; clearTimeout(toast._id); toast._id=setTimeout(()=>toastEl.style.display='none',1100); }

  // ===== Camera (orbit) =====
  function updateCam(){ if(orbit){ tOrbit+=0.0015*orbitSpeed*(60/bpm); const R=dist; camera.position.x=Math.sin(tOrbit)*R; camera.position.z=Math.cos(tOrbit)*R; camera.position.y=56; camera.lookAt(0,12,0); } }

  // ===== First interaction → enable audio & start =====
  let primed=false; canvas.addEventListener('pointerdown', async ()=>{ if(!primed){ audioInit(); if(AC.state!=='running') await AC.resume(); playing=true; primed=true; refreshHub(); toast('Playing — planar hub is live.'); } });

  // ===== Render =====
  function animate(){ requestAnimationFrame(animate); updateCam(); if(Math.abs(hub.inertia)>0.0001){ hub.angle += hub.inertia; hub.inertia *= 0.95; refreshHubLayout(); } renderer.render(scene,camera); }

  // ===== Build and refresh =====
  applySeparation(); refreshHub(); applyView(); buildViewBackups();

  // Keyboard helper: toggle grid/ring with "g", tweak rows/cols with number keys (1-5 rows, 6-9 cols quick)
  addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='g'){ hub.layoutMode = hub.layoutMode==='grid' ? 'ring' : 'grid'; refreshHubLayout(); toast('Layout: '+hub.layoutMode.toUpperCase()); }
    if(/^[1-5]$/.test(e.key)){ hub.gridRows = parseInt(e.key,10); refreshHubLayout(); toast('Rows: '+hub.gridRows); }
    if(/^[6-9]$/.test(e.key)){ hub.gridCols = parseInt(e.key,10)-4; refreshHubLayout(); toast('Cols: '+hub.gridCols); }
  });

  startClock(); animate();

  // ===== Minimal & Added Tests =====
  (function tests(){
    const results=[]; const ok=(n,p)=>results.push({test:n,pass:!!p});
    try{ ok('T1 THREE loaded', !!window.THREE); }catch(e){ ok('T1 THREE loaded', false); }
    try{ ok('T2 VIEWS defined', Array.isArray(VIEWS) && VIEWS.length>=3); }catch(e){ ok('T2 VIEWS defined', false); }
    try{ ok('T3 backup + quick built', viewDotsRow.children.length === VIEWS.length && quickSwitch.children.length >= 8); }catch(e){ ok('T3 backup + quick built', false); }
    try{ ok('T4 HUD shows current view', viewHUD.textContent === VIEWS[viewIdx].name); }catch(e){ ok('T4 HUD shows current view', false); }
    try{ ok('T5 single canvas element', document.querySelectorAll('#canvas').length === 1); }catch(e){ ok('T5 single canvas element', false); }
    try{ ok('T6 hub stacks = 10', hub.stacks.length === 10); }catch(e){ ok('T6 hub stacks = 10', false); }
    try{ syncViewDots(); ok('T7 syncViewDots callable', true); }catch(e){ ok('T7 syncViewDots callable', false); }
    try{ const allPlanar = hub.stacks.every(S=> Math.abs(S.group.position.y - hub.planeY) < 0.6); ok('T8 stacks ~planar', allPlanar); }catch(e){ ok('T8 stacks ~planar', false); }
    try{ const before=hub.angle; hub.angle+=0.1; hub.layoutMode='ring'; refreshHubLayout(); ok('T9 ring layout updates on angle', hub.group.children[0].position.x!==0 || hub.group.children[0].position.z!==0); hub.angle=before; refreshHubLayout(); }catch(e){ ok('T9 ring layout updates on angle', false); }
    try{ ok('T10 hub drag setter exists', typeof hub.stacks[0].def.setter==='function'); }catch(e){ ok('T10 hub drag setter exists', false); }
    try{ refreshHub(); ok('T11 refreshHub callable', true); }catch(e){ ok('T11 refreshHub callable', false); }
    try{ const visBefore=hub.group.visible; hub.shown=false; refreshHub(); const v1=(hub.group.visible===false); hub.shown=true; refreshHub(); const v2=(hub.group.visible===true); ok('T12 hub visibility toggles', v1 && v2); }catch(e){ ok('T12 hub visibility toggles', false); }
    try{ hub.layoutMode='grid'; hub.gridRows=2; hub.gridCols=5; refreshHubLayout(); const pos0=hub.stacks[0].group.position.clone(); ok('T13 grid layout applies', Math.abs(pos0.y-hub.planeY)<0.01); }catch(e){ ok('T13 grid layout applies', false); }
    try{ hub.regular=true; applyDesignAxes(); refreshHubLayout(); const rot=hub.stacks[0].group.rotation; ok('T14 regular grid orthogonal', rot.x===0 && rot.z===0); }catch(e){ ok('T14 regular grid orthogonal', false); }
    try{ const g0=getGap(); cycleSpacingPreset(); const g1=getGap(); ok('T15 spacing cycles', g0!==g1); }catch(e){ ok('T15 spacing cycles', false); }
    // New tests for drum/tube/equigrid/visible
    try{ hub.layoutMode='drum'; refreshHubLayout(); ok('T18 drum layout set', true); }catch(e){ ok('T18 drum layout set', false); }
    try{ hub.layoutMode='tube'; refreshHubLayout(); const varyY = hub.stacks.some(S=> Math.abs(S.group.position.y - hub.planeY) > 0.05); ok('T19 tube has slight Y variance', varyY); }catch(e){ ok('T19 tube has slight Y variance', false); }
    try{ hub.layoutMode='equigrid'; refreshHubLayout(); ok('T20 equigrid applies', true); }catch(e){ ok('T20 equigrid applies', false); }
    try{ const beforeDist=dist; ensureAllVisible(); ok('T21 ensure visible adjusts dist', dist!==beforeDist); }catch(e){ ok('T21 ensure visible adjusts dist', false); }
    try{ ok('T22 ensureAllVisible defined', typeof ensureAllVisible==='function'); ensureAllVisible(); ok('T23 ensureAllVisible runs', true);}catch(e){ ok('T23 ensureAllVisible runs', false); }
    console.table(results);
  })();
})();
</script>
</body>
</html>
